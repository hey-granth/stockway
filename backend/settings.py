"""
Django settings for backend project.

Generated by 'django-admin startproject' using Django 5.2.7.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from pathlib import Path
from core.config import Config

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = Config.SECRET_KEY

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = Config.DEBUG

# ALLOWED_HOSTS configuration for production
ALLOWED_HOSTS = []

if not DEBUG:
    # Production: Allow Render domain and any custom domains
    if Config.RENDER_EXTERNAL_URL:
        # Extract hostname from Render URL (e.g., https://app.onrender.com -> app.onrender.com)
        import re
        match = re.search(r"https?://([^/]+)", Config.RENDER_EXTERNAL_URL)
        if match:
            ALLOWED_HOSTS.append(match.group(1))

    # Allow all .onrender.com domains in production
    ALLOWED_HOSTS.extend([".onrender.com"])

    # Add any additional allowed hosts from environment
    additional_hosts = Config.CORS_ALLOWED_ORIGINS
    for origin in additional_hosts:
        match = re.search(r"https?://([^/]+)", origin)
        if match:
            ALLOWED_HOSTS.append(match.group(1))
else:
    # Development: Allow localhost and common dev hosts
    ALLOWED_HOSTS = ["localhost", "127.0.0.1", "0.0.0.0"]


# Application definition

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "django.contrib.gis",  # PostGIS support
    "rest_framework",
    "corsheaders",
    "django_filters",
    "core",  # Core utilities and shared code
    "accounts",  # Authentication and user management
    "delivery",
    "orders",
    "payments",
    "inventory",
    "warehouses",
    "riders",
    "shopkeepers",
    "notifications",  # Notification system
    "analytics",  # Analytics and reporting
    "django_extensions",
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "core.middleware.CorrelationIDMiddleware",
    "core.middleware.SecurityHeadersMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "backend.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "backend.wsgi.application"


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.contrib.gis.db.backends.postgis",  # PostGIS-enabled backend
        "NAME": Config.DB_NAME,
        "USER": Config.DB_USER,
        "PASSWORD": Config.DB_PASSWORD,
        "HOST": Config.DB_HOST,
        "PORT": Config.DB_PORT,
        "TEST": {
            "NAME": "test_backend_db",  # Local test database
        },
    }
}
AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = "static/"

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

AUTH_USER_MODEL = "accounts.User"

# Detect if running tests
import sys

TESTING = "test" in sys.argv

# REST Framework Configuration
REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "core.authentication.SupabaseAuthentication",  # Supabase JWT authentication
        # Session authentication explicitly disabled for API security
    ],
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticated",
    ],
    "DEFAULT_PARSER_CLASSES": [
        "rest_framework.parsers.JSONParser",
    ],
    "EXCEPTION_HANDLER": "core.exceptions.custom_exception_handler",
    "DEFAULT_THROTTLE_CLASSES": [
        "core.throttling.StandardUserThrottle",
        "core.throttling.StandardAnonThrottle",
    ]
    if not TESTING
    else [],  # Disable throttling during tests
    "DEFAULT_THROTTLE_RATES": {
        "anon": "100/day",
        "user": "1000/day",
        "auth": "10/hour",
        "otp": "5/hour",
        "geo": "60/minute",
        "order_creation": "20/hour",
    },
    # Disable browsable API in production
    "DEFAULT_RENDERER_CLASSES": (
        ["rest_framework.renderers.JSONRenderer"]
        if not Config.DEBUG
        else [
            "rest_framework.renderers.JSONRenderer",
            "rest_framework.renderers.BrowsableAPIRenderer",
        ]
    ),
}

CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": Config.get_redis_url(),
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
            # SSL options for Upstash/production
            "CONNECTION_POOL_KWARGS": {
                "ssl_cert_reqs": None if not Config.DEBUG else None,
            },
        },
    }
}

# Supabase Configuration
SUPABASE_URL = Config.SUPABASE_URL
SUPABASE_KEY = Config.SUPABASE_KEY
SUPABASE_SERVICE_ROLE_KEY = Config.SUPABASE_SERVICE_ROLE_KEY
SUPABASE_JWT_SECRET = Config.SUPABASE_JWT_SECRET

# Optional: Use Supabase Managed Postgres (comment out to use local DB)
# To enable Supabase Postgres, uncomment the lines below and set SUPABASE_DB_* in .env
USE_SUPABASE_DB = Config.SUPABASE_DB_HOST is not None

if USE_SUPABASE_DB:
    DATABASES = {
        "default": {
            "ENGINE": "django.contrib.gis.db.backends.postgis",  # PostGIS-enabled backend
            "NAME": Config.SUPABASE_DB_NAME,
            "USER": Config.SUPABASE_DB_USER,
            "PASSWORD": Config.SUPABASE_DB_PASSWORD,
            "HOST": Config.SUPABASE_DB_HOST,
            "PORT": Config.SUPABASE_DB_PORT,
        }
    }

# ===========================
# TEST DATABASE OVERRIDE
# ===========================
# When running tests, override database to use local PostgreSQL instead of Supabase

if TESTING and Config.TEST_DATABASE_URL:
    # Parse the TEST_DATABASE_URL to extract connection details
    # Format: postgresql://user:password@host:port/dbname
    import re

    url_pattern = r"postgresql://([^:]+):([^@]+)@([^:]+):(\d+)/(.+)"
    match = re.match(url_pattern, Config.TEST_DATABASE_URL)

    if match:
        test_user, test_password, test_host, test_port, test_name = match.groups()
        DATABASES = {
            "default": {
                "ENGINE": "django.contrib.gis.db.backends.postgis",
                "NAME": test_name,
                "USER": test_user,
                "PASSWORD": test_password,
                "HOST": test_host,
                "PORT": test_port,
            }
        }

# ===========================
# SECURITY SETTINGS
# ===========================

# HTTPS and Security Headers
if not DEBUG:
    # Enforce HTTPS
    SECURE_SSL_REDIRECT = True
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True

    # HSTS (HTTP Strict Transport Security)
    SECURE_HSTS_SECONDS = 31536000  # 1 year
    SECURE_HSTS_INCLUDE_SUBDOMAINS = True
    SECURE_HSTS_PRELOAD = True

    # Secure proxy headers
    SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")

# Security headers
SECURE_CONTENT_TYPE_NOSNIFF = True
SECURE_BROWSER_XSS_FILTER = True
X_FRAME_OPTIONS = "DENY"

# Session security
SESSION_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = "Strict"
SESSION_COOKIE_AGE = 3600  # 1 hour

# CSRF settings
CSRF_COOKIE_HTTPONLY = True
CSRF_COOKIE_SAMESITE = "Strict"
CSRF_USE_SESSIONS = False

# CORS Configuration
CORS_ALLOW_CREDENTIALS = True
CORS_ALLOWED_ORIGINS = (
    Config.CORS_ALLOWED_ORIGINS if hasattr(Config, "CORS_ALLOWED_ORIGINS") else []
)
CORS_ALLOW_HEADERS = [
    "accept",
    "accept-encoding",
    "authorization",
    "content-type",
    "dnt",
    "origin",
    "user-agent",
    "x-csrftoken",
    "x-requested-with",
    "x-correlation-id",
]

# ===========================
# CELERY CONFIGURATION
# ===========================

# Dynamic broker and backend configuration based on environment
CELERY_BROKER_URL = Config.get_redis_url()
CELERY_RESULT_BACKEND = Config.get_redis_url()

# Celery broker connection retry settings
CELERY_BROKER_CONNECTION_RETRY_ON_STARTUP = True
CELERY_BROKER_CONNECTION_RETRY = True
CELERY_BROKER_CONNECTION_MAX_RETRIES = 10

# SSL configuration for Upstash Redis
if Config.UPSTASH_REDIS_REST_URL:
    # Production: Upstash requires SSL
    CELERY_REDIS_BACKEND_USE_SSL = {
        "ssl_cert_reqs": "none",  # Upstash uses verified certs, but we skip client verification
    }
    CELERY_BROKER_USE_SSL = {
        "ssl_cert_reqs": "none",
    }

# Celery task settings
CELERY_ACCEPT_CONTENT = ["json"]
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"
CELERY_TIMEZONE = "UTC"
CELERY_TASK_TRACK_STARTED = True
CELERY_TASK_TIME_LIMIT = 30 * 60  # 30 minutes
CELERY_TASK_SOFT_TIME_LIMIT = 25 * 60  # 25 minutes

# Task result settings
CELERY_RESULT_EXPIRES = 3600  # 1 hour - results expire after 1 hour
CELERY_TASK_IGNORE_RESULT = False  # Keep results for monitoring

# Worker settings for production
CELERY_WORKER_PREFETCH_MULTIPLIER = 1  # Disable prefetching for fair task distribution
CELERY_WORKER_MAX_TASKS_PER_CHILD = 1000  # Recycle worker after 1000 tasks
CELERY_TASK_ACKS_LATE = True  # Acknowledge task after completion (safer for retries)
CELERY_TASK_REJECT_ON_WORKER_LOST = True  # Requeue tasks if worker crashes

# Celery queue routing
CELERY_TASK_ROUTES = {
    "notifications.send_notification": {"queue": "notifications"},
    "notifications.cleanup_old_notifications": {"queue": "notifications"},
    "payouts.compute_for_order": {"queue": "payments"},
    "payouts.nightly_rollup": {"queue": "payments"},
    "payouts.notify_completion": {"queue": "notifications"},
    "payouts.notify_creation": {"queue": "notifications"},
    "payouts.notify_settlement": {"queue": "notifications"},
}

# Celery beat schedule for periodic tasks
CELERY_BEAT_SCHEDULE = {
    "cleanup-old-notifications": {
        "task": "notifications.cleanup_old_notifications",
        "schedule": 86400.0,  # Daily (24 hours in seconds)
    },
    "nightly-payout-rollup": {
        "task": "payouts.nightly_rollup",
        "schedule": 86400.0,  # Daily at midnight (you can use crontab for specific time)
        # To run at specific time: from celery.schedules import crontab
        # "schedule": crontab(hour=0, minute=0),  # Run at midnight
    },
}

# Optional: Supabase Edge Function URL for push/SMS delivery
SUPABASE_EDGE_FUNCTION_URL = (
    Config.SUPABASE_EDGE_FUNCTION_URL
    if hasattr(Config, "SUPABASE_EDGE_FUNCTION_URL")
    else None
)

# ===========================
# LOGGING CONFIGURATION
# ===========================

LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "verbose": {
            "format": "{levelname} {asctime} {module} {process:d} {thread:d} {message}",
            "style": "{",
        },
        "simple": {
            "format": "{levelname} {message}",
            "style": "{",
        },
    },
    "filters": {
        "require_debug_false": {
            "()": "django.utils.log.RequireDebugFalse",
        },
        "require_debug_true": {
            "()": "django.utils.log.RequireDebugTrue",
        },
    },
    "handlers": {
        "console": {
            "level": "INFO",
            "class": "logging.StreamHandler",
            "formatter": "verbose",
        },
        "file": {
            "level": "WARNING",
            "class": "logging.handlers.RotatingFileHandler",
            "filename": BASE_DIR / "logs" / "django.log",
            "maxBytes": 1024 * 1024 * 10,  # 10 MB
            "backupCount": 5,
            "formatter": "verbose",
        },
        "security_file": {
            "level": "WARNING",
            "class": "logging.handlers.RotatingFileHandler",
            "filename": BASE_DIR / "logs" / "security.log",
            "maxBytes": 1024 * 1024 * 10,  # 10 MB
            "backupCount": 10,
            "formatter": "verbose",
        },
    },
    "loggers": {
        "django": {
            "handlers": ["console", "file"],
            "level": "INFO",
            "propagate": False,
        },
        "django.security": {
            "handlers": ["security_file"],
            "level": "WARNING",
            "propagate": False,
        },
        "core.authentication": {
            "handlers": ["console", "security_file"],
            "level": "WARNING",
            "propagate": False,
        },
        "core.permissions": {
            "handlers": ["console", "security_file"],
            "level": "WARNING",
            "propagate": False,
        },
        "orders": {
            "handlers": ["console", "file"],
            "level": "INFO",
            "propagate": False,
        },
    },
    "root": {
        "handlers": ["console"],
        "level": "INFO",
    },
}

# Create logs directory if it doesn't exist
import os

os.makedirs(BASE_DIR / "logs", exist_ok=True)

DISABLE_COLLECTSTATIC = True